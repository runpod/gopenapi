// Code generated by gopenapi. DO NOT EDIT.

{{- range .Operations }}
{{- if .HasPathParams }}
export interface {{ .StructName }}PathParams {
  {{- range .PathParams }}
  {{ .Name }}: {{ .GoType | typescript_type }};
  {{- end }}
}
{{- end }}

{{- if .HasQueryParams }}
export interface {{ .StructName }}QueryParams {
  {{- range .QueryParams }}
  {{ .Name }}?: {{ .GoType | typescript_type }};
  {{- end }}
}
{{- end }}

{{- if .HasHeaderParams }}
export interface {{ .StructName }}HeaderParams {
  {{- range .HeaderParams }}
  {{ .Name }}?: {{ .GoType | typescript_type }};
  {{- end }}
}
{{- end }}

{{- if .HasRequestBody }}
export interface {{ .StructName }}RequestBody {
  {{- range .RequestBodyFields }}
  {{ .Name }}: {{ .GoType | typescript_type }};
  {{- end }}
}
{{- end }}

{{- if .HasResponseBody }}
export interface {{ .StructName }}Response {
  {{- range .ResponseFields }}
  {{ .Name }}: {{ .GoType | typescript_type }};
  {{- end }}
}
{{- end }}

{{- end }}

export interface ApiClientConfig {
  baseURL: string;
  headers?: Record<string, string>;
  timeout?: number;
}

export class ApiError extends Error {
  constructor(
    public statusCode: number,
    message: string,
    public responseBody?: any
  ) {
    super(`API error ${statusCode}: ${message}`);
    this.name = 'ApiError';
  }
}

export class {{ .PackageName | title }}Client {
  private baseURL: string;
  private headers: Record<string, string>;
  private timeout: number;

  constructor(config: ApiClientConfig) {
    this.baseURL = config.baseURL.replace(/\/$/, '');
    this.headers = config.headers || {};
    this.timeout = config.timeout || 30000;
  }

  private async request<T>(
    method: string,
    path: string,
    options: {
      params?: Record<string, any>;
      headers?: Record<string, string>;
      body?: any;
    } = {}
  ): Promise<T> {
    const url = new URL(path, this.baseURL);
    
    // Add query parameters
    if (options.params) {
      Object.entries(options.params).forEach(([key, value]) => {
        if (value !== undefined && value !== null) {
          url.searchParams.append(key, String(value));
        }
      });
    }

    const requestHeaders: Record<string, string> = {
      'Content-Type': 'application/json',
      ...this.headers,
      ...options.headers,
    };

    const requestInit: RequestInit = {
      method,
      headers: requestHeaders,
    };

    if (options.body !== undefined) {
      requestInit.body = JSON.stringify(options.body);
    }

    // Add timeout support
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    requestInit.signal = controller.signal;

    try {
      const response = await fetch(url.toString(), requestInit);
      clearTimeout(timeoutId);

      if (!response.ok) {
        const errorBody = await response.text();
        throw new ApiError(response.status, response.statusText, errorBody);
      }

      const contentType = response.headers.get('content-type');
      if (contentType && contentType.includes('application/json')) {
        return await response.json();
      } else {
        return await response.text() as unknown as T;
      }
    } catch (error) {
      clearTimeout(timeoutId);
      if (error instanceof ApiError) {
        throw error;
      }
      throw new ApiError(0, `Network error: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

{{- range .Operations }}
  /**
   * {{ .Description }}
   */
  async {{ .OperationId | camel_case }}(
    {{- if .HasPathParams }}
    path: {{ .StructName }}PathParams,
    {{- end }}
    {{- if .HasQueryParams }}
    query?: {{ .StructName }}QueryParams,
    {{- end }}
    {{- if .HasHeaderParams }}
    headers?: {{ .StructName }}HeaderParams,
    {{- end }}
    {{- if .HasRequestBody }}
    body: {{ .StructName }}RequestBody,
    {{- end }}
  ): Promise<{{ if .HasResponseBody }}{{ .StructName }}Response{{ else }}void{{ end }}> {
    // Build path
    let pathStr = "{{ .Path }}";
    {{- range .PathParams }}
    pathStr = pathStr.replace("{{ .PathPattern }}", String(path.{{ .Name }}));
    {{- end }}

    // Build query parameters
    const queryParams: Record<string, any> = {};
    {{- if .HasQueryParams }}
    if (query) {
      {{- range .QueryParams }}
      if (query.{{ .Name }} !== undefined) {
        queryParams["{{ .Name }}"] = query.{{ .Name }};
      }
      {{- end }}
    }
    {{- end }}

    // Build headers
    const requestHeaders: Record<string, string> = {};
    {{- if .HasHeaderParams }}
    if (headers) {
      {{- range .HeaderParams }}
      if (headers.{{ .Name }} !== undefined) {
        requestHeaders["{{ .Name }}"] = String(headers.{{ .Name }});
      }
      {{- end }}
    }
    {{- end }}

    return this.request<{{ if .HasResponseBody }}{{ .StructName }}Response{{ else }}void{{ end }}>(
      "{{ .Method }}",
      pathStr,
      {
        params: queryParams,
        headers: requestHeaders,
        {{- if .HasRequestBody }}
        body,
        {{- end }}
      }
    );
  }

{{- end }}
} 