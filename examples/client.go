// Code generated by gopenapi. DO NOT EDIT.
package client

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// Client represents the HTTP client for the API
type Client struct {
	BaseURL    string
	HTTPClient *http.Client
	Headers    map[string]string
}

// NewClient creates a new API client
func NewClient(baseURL string) *Client {
	return &Client{
		BaseURL:    strings.TrimSuffix(baseURL, "/"),
		HTTPClient: &http.Client{},
		Headers:    make(map[string]string),
	}
}

// SetHeader sets a default header for all requests
func (c *Client) SetHeader(key, value string) {
	c.Headers[key] = value
}

// Error represents an API error response
type Error struct {
	StatusCode int
	Message    string
	Body       []byte
}

func (e *Error) Error() string {
	return fmt.Sprintf("API error %d: %s", e.StatusCode, e.Message)
}



// GetUserByIdPathParams contains path parameters for getUserById
type GetUserByIdPathParams struct {
	Id int `json:"id"`
}



// GetUserByIdQueryParams contains query parameters for getUserById
type GetUserByIdQueryParams struct {
	Include string `json:"include"`
}



// GetUserByIdHeaderParams contains header parameters for getUserById
type GetUserByIdHeaderParams struct {
	Authorization string `json:"Authorization"`
}




// GetUserByIdOptions contains all parameters for getUserById
type GetUserByIdOptions struct {
	Path   *GetUserByIdPathParams   `json:"path,omitempty"`
	Query  *GetUserByIdQueryParams  `json:"query,omitempty"`
	Headers *GetUserByIdHeaderParams `json:"headers,omitempty"`
}


// GetUserByIdResponse represents the response from getUserById
type GetUserByIdResponse struct {
	ID int `json:"id"`
	Name string `json:"name"`
	Email string `json:"email"`
}


// getUserById Retrieve a user by their unique identifier
func (c *Client) GetUserById(ctx context.Context, opts *GetUserByIdOptions) (*GetUserByIdResponse, error) {
	if opts == nil {
		opts = &GetUserByIdOptions{}
	}

	// Build URL path
	path := "/users/{id}"
	if opts.Path != nil {
		path = strings.ReplaceAll(path, "{id}", strconv.Itoa(opts.Path.Id))
	}


	// Build query parameters
	params := url.Values{}
	if opts.Query != nil {
		if opts.Query.Include != "" {
		params.Add("include", opts.Query.Include)
	}
	}


	// Construct full URL
	fullURL := c.BaseURL + path
	if len(params) > 0 {
		fullURL += "?" + params.Encode()
	}

	// Prepare request body
	var body io.Reader


	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", fullURL, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set default headers
	for key, value := range c.Headers {
		req.Header.Set(key, value)
	}



	// Set custom headers
	if opts.Headers != nil {
		if opts.Headers.Authorization != "" {
		req.Header.Set("Authorization", opts.Headers.Authorization)
	}
	}


	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, &Error{
			StatusCode: resp.StatusCode,
			Message:    string(respBody),
			Body:       respBody,
		}
	}

	// Parse response
	var result GetUserByIdResponse
	if len(respBody) > 0 {
		if err := json.Unmarshal(respBody, &result); err != nil {
			return nil, fmt.Errorf("failed to unmarshal response: %w", err)
		}
	}
	return &result, nil
}










// ListAllUsersOptions contains all parameters for listAllUsers
type ListAllUsersOptions struct {
}



// listAllUsers Retrieve a list of all users
func (c *Client) ListAllUsers(ctx context.Context, opts *ListAllUsersOptions) (interface{}, error) {
	if opts == nil {
		opts = &ListAllUsersOptions{}
	}

	// Build URL path
	path := "/users"


	// Build query parameters
	params := url.Values{}


	// Construct full URL
	fullURL := c.BaseURL + path
	if len(params) > 0 {
		fullURL += "?" + params.Encode()
	}

	// Prepare request body
	var body io.Reader


	// Create request
	req, err := http.NewRequestWithContext(ctx, "GET", fullURL, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set default headers
	for key, value := range c.Headers {
		req.Header.Set(key, value)
	}



	// Set custom headers


	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, &Error{
			StatusCode: resp.StatusCode,
			Message:    string(respBody),
			Body:       respBody,
		}
	}

	// Return raw response for non-JSON responses
	return string(respBody), nil
}









// CreateNewUserRequestBody contains the request body for createNewUser
type CreateNewUserRequestBody struct {
	Name string `json:"name"`
	Email string `json:"email"`
}


// CreateNewUserOptions contains all parameters for createNewUser
type CreateNewUserOptions struct {
	Body   *CreateNewUserRequestBody   `json:"body,omitempty"`
}


// CreateNewUserResponse represents the response from createNewUser
type CreateNewUserResponse struct {
	ID int `json:"id"`
	Name string `json:"name"`
	Email string `json:"email"`
}


// createNewUser Create a new user account
func (c *Client) CreateNewUser(ctx context.Context, opts *CreateNewUserOptions) (*CreateNewUserResponse, error) {
	if opts == nil {
		opts = &CreateNewUserOptions{}
	}

	// Build URL path
	path := "/users"


	// Build query parameters
	params := url.Values{}


	// Construct full URL
	fullURL := c.BaseURL + path
	if len(params) > 0 {
		fullURL += "?" + params.Encode()
	}

	// Prepare request body
	var body io.Reader
	if opts.Body != nil {
		jsonBody, err := json.Marshal(opts.Body)
		if err != nil {
			return nil, fmt.Errorf("failed to marshal request body: %w", err)
		}
		body = bytes.NewReader(jsonBody)
	}


	// Create request
	req, err := http.NewRequestWithContext(ctx, "POST", fullURL, body)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Set default headers
	for key, value := range c.Headers {
		req.Header.Set(key, value)
	}

	// Set content type for request body
	if opts.Body != nil {
		req.Header.Set("Content-Type", "application/json")
	}


	// Set custom headers


	// Execute request
	resp, err := c.HTTPClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute request: %w", err)
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	// Check for error status codes
	if resp.StatusCode >= 400 {
		return nil, &Error{
			StatusCode: resp.StatusCode,
			Message:    string(respBody),
			Body:       respBody,
		}
	}

	// Parse response
	var result CreateNewUserResponse
	if len(respBody) > 0 {
		if err := json.Unmarshal(respBody, &result); err != nil {
			return nil, fmt.Errorf("failed to unmarshal response: %w", err)
		}
	}
	return &result, nil
}

 